

function VoronoiMap() {

    var current_loss = null;
    var jitter_start_size = 200;
    var jitter_multi_when_previous_improved = 1;
    var jitter_multi_when_previous_worse = 0.9;
    var timer = null;


    var bounds = VMT.mapholder.map.getBounds(),
    topLeft = VMT.mapholder.map.latLngToLayerPoint(bounds.getNorthWest()),
    bottomRight = VMT.mapholder.map.latLngToLayerPoint(bounds.getSouthEast())
        
    var voronoi_fn = d3.voronoi()
            .x(function(d) {
                return d.x ;  //To avoid two points being at the same pixel values and therefore having an uncomputable voronoi
            })
            .y(function(d) {
                return d.y ;  //To avoid two points being at the same pixel values
            })
            .extent([
                [0, 0],
                [bottomRight.x, bottomRight.y]
            ])

    this.draw_from_scratch = function() {

        //Get layers 
    
        me.voronoi_cells_layer = d3.select("#voronoi_cells_layer")
        me.demand_lines_layer = d3.select("#demand_lines_layer")
        me.facility_location_layer = d3.select("#facility_location_layer")

        // Draw cells

        redraw_voronoi()

    }

    this.locations = []

    

    new_location = {
      "id": "hello3",
      "lat": 51.9039908342,
      "lng": 0.1283539949,
        previous_jitter: [0, 0],
        previous_loss_improve: false,
        jitter_size: jitter_start_size
    }

    // this.locations.push(new_location)

    me = this;

    function update_dots(point) {



        new_location = {
          "id": "hello5",
          "lat": point.latlng.lat,
          "lng": point.latlng.lng,
          "x": point.layerPoint.x,
          "y": point.layerPoint.y,
          previous_jitter: [0, 0],
        previous_loss_improve: false,
        jitter_size: jitter_start_size
        }
        me.locations.push(new_location)


        
        redraw_voronoi()

    }

    var drag = d3.drag()
        .on("drag", dragged)

    function dragged(d) {


        d.y = d3.event.y
        d.x = d3.event.x

        // convert to lat lng
        latlng = VMT.mapholder.map.layerPointToLatLng([d.x,d.y])

     
        this.__data__.data.lat = latlng.lat;
        this.__data__.data.lng = latlng.lng;

        //update locations data
        me.locations = d3.select("#facility_location_layer").selectAll(".locations_circles").data()

        me.locations = _.map(me.locations, function(d) {
            return d.data
        })

        // current_loss = compute_loss()
        redraw_voronoi()
    }



    function redraw_voronoi() {

        var bounds = VMT.mapholder.map.getBounds(),
        topLeft = VMT.mapholder.map.latLngToLayerPoint(bounds.getNorthWest()),
        bottomRight = VMT.mapholder.map.latLngToLayerPoint(bounds.getSouthEast())
            
        var voronoi_fn = d3.voronoi()
                .x(function(d) {
                    return d.x ;  //To avoid two points being at the same pixel values and therefore having an uncomputable voronoi
                })
                .y(function(d) {
                    return d.y ;  //To avoid two points being at the same pixel values
                })
                .extent([
                    [topLeft.x, topLeft.y],
                    [bottomRight.x, bottomRight.y]
                ])

        // Convert lat lng to points
        me.locations = _.map(me.locations,function(d) {

            var latlng = new L.LatLng(d.lat, d.lng);
            var point = VMT.mapholder.map.latLngToLayerPoint(latlng);

            d.x = point.x;
            d.y = point.y;

            return d
  
        });


        var diagram = voronoi_fn.polygons(me.locations)

        function path_generator(d) {
    
            return d ? "M" + d.join("L") + "Z" : null
        }

        var v_cells = me.voronoi_cells_layer.selectAll(".voronoicells")
            .data(diagram)

        v_cells.enter().append("path").merge(v_cells)
            .attr("class", "voronoicells")
            .attr("d", function(d) {
                return path_generator(d)
            })
            .attr("fill", "black")

        var circles = me.facility_location_layer.selectAll(".locations_circles")
            .data(diagram)

        circles = circles.enter().append("circle")
            .attr("r", function(d) {
                return 10
            })
            .attr("class", "locations_circles")
            .call(drag)
            .merge(circles)
            .attr("cx", function(d) {
                return d.data.x
            })
            .attr("cy", function(d) {
                return d.data.y
            })
            .style("stroke", "lightblue")
            .style("stroke-width", 5)
            .attr("fill", "black")
            .attr("class", "locations_circles")


        draw_loss()

    }

    function draw_loss() {

        if (me.locations.length ==0) { return null}

        var loss_dict = compute_loss()
        var loss_data = loss_dict.loss_data
        var total_loss = loss_dict.total_loss

        // Get min and max distance
        var min_loss = _.min(loss_data, function(d) {
            return d.loss
        })["loss"]
        var max_loss = _.max(loss_data, function(d) {
            return d.loss
        })["loss"]
        var mid = (min_loss + max_loss) / 2

        var loss_line_colour_scale = d3.scaleLinear().domain([min_loss, mid, max_loss]).range(["#04CE4E", "#CE8E00", "#CE043A"])
        var loss_line_width_scale = d3.scaleLinear().domain([min_loss, mid, max_loss]).range([0.5, 1, 10])
        var loss_line_opacity_scale = d3.scaleLinear().domain([min_loss, mid, max_loss]).range([0.3, 0.5, 1])
      
         me.demand_lines_layer.selectAll(".demand_data_lines").remove()

         me.demand_lines_layer.selectAll(".demand_data_lines").data(loss_data)
            .enter()
            .append("line")
            .attr("x1", function(d) {
                return d.this_point.x
            })
            .attr("y1", function(d) {
                return d.this_point.y
            })
            .attr("x2", function(d) {
                return d.closest_point.x
            })
            .attr("y2", function(d) {
                return d.closest_point.y
            })
            .style("stroke", function(d) {
                return loss_line_colour_scale(d.loss)
            })
            .style("stroke-width", function(d) {
                return loss_line_width_scale(d.loss)
            })
            .style("stroke-opacity", function(d) {
                return loss_line_opacity_scale(d.loss)
            })
            .attr("class", "demand_data_lines")

            // Update hover panel
            var template_dict = {}
            template_dict.loss = d3.format(",.0f")(total_loss);
            var source = $("#hp_info").html();
            var template = Handlebars.compile(source);
            var html = template(template_dict);
            d3.select('#hover_panel')
                .html(html)


    }

    function compute_loss() {

        var loss_data = _.map(VMT.dataholder.demand_points, function(d) {
            var closest_point = get_closest_point(d)
            var this_distance = get_distance(d, closest_point)
            return {
                this_point: d,
                closest_point: closest_point,
                distance: this_distance,
                demand: d.demand_for_prison,
                loss: this_distance * d.demand_for_prison
            }
        })



        var total_loss = 0
        _.each(loss_data, function(d) {
            total_loss = total_loss + d.loss
        })

        return {
            loss_data: loss_data,
            total_loss: total_loss
        }

    }

    function get_closest_point(demand_point) {
        var locations2 = _.sortBy(me.locations, function(this_location) {
            return get_distance(this_location, demand_point)
        })
        return locations2[0]
    }

    function get_distance(p1, p2) {

        
        var latlng1 = new L.LatLng(p1.lat, p1.lng);
        var latlng2 = new L.LatLng(p2.lat, p2.lng);

        return latlng1.distanceTo(latlng2)/1000
    }

    this.draw_from_scratch()

    VMT.mapholder.map.on('viewreset moveend', this.draw_from_scratch);

    VMT.mapholder.map.on("click", function(d) {
        if (timer) {
            clearTimeout(timer)
        };
        update_dots(d)
    })

    function optimise_tick() {

        _.each(me.locations, function(d) {
            d.previous_jitter=[0, 0],
            d.previous_loss_improve=false,
            d.jitter_size=jitter_start_size
        })
        timer = setInterval(function() {
            optimise_locations()
        }, 0)
    }

    $('#optimise').on('click', optimise_tick)

    $('#stop').on('click', function(d) {
        clearTimeout(timer)
    })

    function optimise_locations() {
        // For each location, try a small movement and if it improves the loss function, do it
        if (!(current_loss)) {
            current_loss = compute_loss()
        }
        console.log("reoptimising")

        for (var i = 0; i < me.locations.length; i++) {

            var saved_location = jQuery.extend({}, me.locations[i]);

            // if loss improved previousy
            if (me.locations[i].previous_loss_improve) {
                this_jitter = _.map(me.locations[i].previous_jitter, function(d) {
                    return d * jitter_multi_when_previous_improved
                })
            } else {

                me.locations[i].jitter_size = me.locations[i].jitter_size * jitter_multi_when_previous_worse;

                
            }

            //Ocasionally add large jitter just to check it doesn't make things better
                var js = me.locations[i].jitter_size

                if (d3.randomUniform()() > 0.95) {
                    me.locations[i].jitter_size = jitter_start_size * d3.randomUniform()();
                    js = me.locations[i].jitter_size;
                }

                this_jitter = _.map([0, 0], function(d) {
                    return d3.randomUniform(-js, js)()
                })


            //Modify the location of this point
            me.locations[i].x += this_jitter[0]
            me.locations[i].y += this_jitter[1]

            var latlng = VMT.mapholder.map.layerPointToLatLng([me.locations[i].x,me.locations[i].y])
            me.locations[i].lat = latlng.lat;
            me.locations[i].lng = latlng.lng;


            me.locations[i].previous_jitter = this_jitter

            //Recompute loss
            new_loss = compute_loss()


            //If new loss is worse, undo 
            if (new_loss.total_loss > current_loss.total_loss) {
                me.locations[i] = saved_location;
                me.locations[i].jitter_size = me.locations[i].jitter_size * jitter_multi_when_previous_worse;
                me.locations[i].previous_loss_improve = false;
                

            } else {
                current_loss = new_loss
                me.locations[i].previous_loss_improve = true;


            }


        }

        //Ocasionally add large jitter to all points just to check it doesn't make things better - do this when all jitters are small

        var max_jitter_size = _.map(me.locations, function(d) {return d.jitter_size})
        var max_jitter_size = _.max(test)
        var test =  (d3.randomUniform()() > 0.75 & max_jitter_size<0.0001) 


        if (test) {
            saved_locations = $.extend(true, [], me.locations);  
            for (var i = 0; i < me.locations.length; i++) {

                js = d3.randomUniform(-jitter_start_size, jitter_start_size)()

                this_jitter = _.map([0, 0], function(d) {
                        return d3.randomUniform(-js, js)()
                    })
                

                if (d3.randomUniform()() > 0.5) {

                    //Modify the location of this point
                    me.locations[i].x += this_jitter[0]
                    me.locations[i].y += this_jitter[1]
                    me.locations[i].previous_jitter = [0,0]
                    me.locations[i].previous_loss_improve = false
                    me.locations[i].jitter_size = jitter_start_size

                    var latlng = VMT.mapholder.map.layerPointToLatLng([me.locations[i].x,me.locations[i].y])
                    me.locations[i].lat = latlng.lat;
                    me.locations[i].lng = latlng.lng;


                }
                

            }


            new_loss = compute_loss()

            //If new loss is worse, undo 
            if (new_loss.total_loss >= current_loss.total_loss) {
                me.locations = saved_locations;

            } else {
                current_loss = new_loss
                console.log("randomised improvement")

            }
        }




        redraw_voronoi()


    }





}